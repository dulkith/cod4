// This file has been autogenerated using CoD4X 1.8 server. //
// If it contains wrong data, please create issue here:     //
//    https://github.com/callofduty4x/CoD4x_Server/issues   //
#include maps\mp\gametypes\_hud_util;
/*music()
{
	if( !isDefined( game["song"] ) )
		game["song"] = 1;
	
	song = "end_round_" + game["song"];
	
	MusicPlay( song );
	
	if( game["song"] < level.leiizko_dvars[ "music_num" ] )
		game["song"]++;
	else
		game["song"] = 1;
}*/

music()
{
	if( !isDefined( game["song"] ) )
		game["song"] = 1;
	
	if( level.leiizko_dvars[ "music_num" ] == 0 )
	{
		setDvar( "music", 0 );
		logPrint( "Music Error: Music enabled while number of songs is set to 0... Turning off music\n" );
		return;
	}
	
	level.song = "end_round_" + game["song"];
	
	if( game["song"] < level.leiizko_dvars[ "music_num" ] )
		game["song"]++;
	else
		game["song"] = 1;
}

killcam(
	attackerNum, // entity number of the attacker
	killcamentity, // entity number of the attacker's killer entity aka helicopter or airstrike
	sWeapon, // killing weapon
	predelay, // time between player death and beginning of killcam
	offsetTime, // something to do with how far back in time the killer was seeing the world when he made the kill; latency related, sorta
	maxtime, // time remaining until map ends; the killcam will never last longer than this. undefined = no limit
	attacker, // entity object of attacker
	victim,  // entity object of victim
	time,
	thistime
)
{
	self endon("disconnect");
	self endon("spawned");
	level endon("game_ended");

	if(attackerNum < 0)
	{
		return;
	}
		
	//iprintlnbold( "Killcam started for: " + self.name );
	wait .1;

	// length from killcam start to killcam end
	if (getdvar("scr_killcam_time") == "") {
		camtime = 8;
	}
	else
		camtime = getdvarfloat("scr_killcam_time");
	
	if (isdefined(maxtime)) {
		if (camtime > maxtime)
			camtime = maxtime;
		if (camtime < .05)
			camtime = .05;
	}
	
	postdelay = 3;
	
	/* timeline:
	
	|        camtime       |      postdelay      |
	|                      |   predelay    |
	
	^ killcam start        ^ player death        ^ killcam end
	                                       ^ player starts watching killcam
	
	*/
	
	killcamlength = camtime + postdelay;
	
	// don't let the killcam last past the end of the round.
	if (isdefined(maxtime) && killcamlength > maxtime)
	{
		// first trim postdelay down to a minimum of 1 second.
		// if that doesn't make it short enough, trim camtime down to a minimum of 1 second.
		// if that's still not short enough, cancel the killcam.
		if (maxtime < 2)
		{
			return;
		}

		if (maxtime - camtime >= 1) {
			// reduce postdelay so killcam ends at end of match
			postdelay = maxtime - camtime;
		}
		else {
			// distribute remaining time over postdelay and camtime
			postdelay = 1;
			camtime = maxtime - 1;
		}
		
		// recalc killcamlength
		killcamlength = camtime + postdelay;
	}
	
	self.killcam = true;

	killcamoffset = camtime + predelay;
	
	self notify ( "begin_killcam", getTime() );
	
	if( isDefined( level.finalcamshowing ) )
	{
		self thread finalHUD( attacker, victim );
		self setClientDvar( "cg_airstrikekillcamdist", 100 );
	}
	else
		self thread regularHUD( attacker );
	
	self.sessionstate = "spectator";
	self.spectatorclient = attackerNum;
	self.killcamentity = killcamentity;
	
	if( isDefined( thistime ) )
		self.archivetime = (thistime - time)/1000 + killcamoffset + 0.5;
	else
		self.archivetime = killcamoffset - 4;

	self.killcamlength = killcamlength;
	self.psoffsettime = offsetTime;

	// ignore spectate permissions
	self allowSpectateTeam("allies", true);
	self allowSpectateTeam("axis", true);
	self allowSpectateTeam("freelook", true);
	self allowSpectateTeam("none", true);
	
	// wait till the next server frame to allow code a chance to update archivetime if it needs trimming
	wait 0.05;

	if ( self.archivetime <= predelay ) // if we're not looking back in time far enough to even see the death, cancel
	{
		self.sessionstate = "dead";
		self.spectatorclient = -1;
		self.killcamentity = -1;
		self.archivetime = 0;
		self.psoffsettime = 0;
		
		return;
	}

	self thread spawnedKillcamCleanup();
	self thread endedKillcamCleanup();
	
	if( !isDefined( level.finalcamshowing ) )
		self thread waitSkipKillcamButton();
	self thread waitKillcamTime();

	self waittill("end_killcam");

	if( isDefined( self.killcam ) )
	{
		self endKillcam();

		self.sessionstate = "dead";
		self.spectatorclient = -1;
		self.killcamentity = -1;
		self.archivetime = 0;
		self.psoffsettime = 0;
	}
}

finalHUD( attacker, victim )
{
	self endon( "disconnect" );
	
	level.randomcolour = ( randomFloatRange( 0, 1 ), randomFloatRange( 0, 1 ), randomFloatRange( 0, 1 ) );

	self.villain = createFontString( "default", level.lowerTextFontSize );
	self.villain setPoint( "CENTER", "BOTTOM", -500, -110 ); 
	self.villain.alignX = "right";
	self.villain.archived = false;
	if( isDefined( attacker ) )
		self.villain setPlayerNameString( attacker );
	else
		self.villain setText( "[Player Disconnected]" );
	self.villain.alpha = 1;
	self.villain.glowalpha = 1;
	self.villain.glowColor = level.randomcolour;
	self.villain moveOverTime( 4 );
	self.villain.x = -20;  

	self.versus = createFontString( "default", level.lowerTextFontSize );
	self.versus.alpha = 0;
	self.versus setPoint( "CENTER", "BOTTOM", 0, -110 );  
	self.versus.archived = false;
	self.versus setText( "vs" );
	self.versus.glowColor = level.randomcolour;
	self.versus fadeOverTime( 4 );
	self.versus.alpha = 1;
  
	self.victim = createFontString( "default", level.lowerTextFontSize );
	self.victim setPoint( "CENTER", "BOTTOM", 500, -110 );
	self.victim.alignX = "left";  
	self.victim.archived = false;
	if( isDefined( victim ) )
		self.victim setPlayerNameString( victim );
	else
		self.victim setText( "[Player Disconnected]" );
	self.victim.glowalpha = 1; 
	self.victim.glowColor = level.randomcolour;
	self.victim moveOverTime( 4 );
	self.victim.x = 20; 
}

regularHUD( attacker )
{
	self endon( "disconnect" );
	level endon( "game_ended" );

	self thread end_clean();
	
	self.regularHUD = newClientHudElem( self );
	if( isDefined( attacker ) )
		self.regularHUD setText( "You have been slain by ^1" + attacker.name );
	else
		self.regularHUD setText( "Your killer has disconnected." );
	self.regularHUD.alpha = 1;
	self.regularHUD.glowAlpha = 1;
	self.regularHUD.glowColor = ( 0.88627, 0.40321, 0.16078 );
	self.regularHUD.archived = false;
	self.regularHUD.alignX = "center";
	self.regularHUD.alignY = "bottom";
	self.regularHUD.horzAlign = "center";
	self.regularHUD.vertAlign = "bottom";
	self.regularHUD.x = 0;
	self.regularHUD.y = -40;
	self.regularHUD.fontscale = 2;
	self.regularHUD.color = ( 1, 1, 1 );
	
	self waittill( "end_killcam" );
	
	if( isDefined( self.regularHUD ) )
		self.regularHUD destroy();
}

end_clean()
{
	self endon( "end_killcam" );
	self endon( "disconnect" );
	
	level waittill( "game_ended" );
	
	if( isDefined( self.regularHUD ) )
		self.regularHUD destroy();
}

waitKillcamTime()
{
	self endon("disconnect");
	self endon("end_killcam");

	wait(self.killcamlength - 0.05);
	self notify("end_killcam");
}

waitSkipKillcamButton()
{
	self endon("disconnect");
	self endon("end_killcam");

	while(self useButtonPressed())
		wait .05;

	while(!(self useButtonPressed()))
		wait .05;

	self notify("end_killcam");
}

endKillcam()
{
	self endon( "disconnect" );

	if( isDefined( self.regularHUD ) )
		self.regularHUD destroy();
		
	if( isDefined( self.villain ) )
		self.villain destroy();
		
	if( isDefined( self.versus ) )
		self.versus destroy();
		
	if( isDefined( self.victim ) )
		self.victim destroy();
	
	self.killcam = undefined;
	
	//iprintlnbold( "Killcam ended for: " + self.name );
	
	self thread maps\mp\gametypes\_spectating::setSpectatePermissions();
	wait .1;
}

spawnedKillcamCleanup()
{
	self endon("end_killcam");
	self endon("disconnect");

	self waittill("spawned");
	self endKillcam();
	self notify("end_killcam");
}

spectatorKillcamCleanup( attacker )
{
	self endon("end_killcam");
	self endon("disconnect");
	attacker endon ( "disconnect" );

	attacker waittill ( "begin_killcam", attackerKcStartTime );
	waitTime = max( 0, (attackerKcStartTime - self.deathTime) - 50 );
	wait (waitTime);
	self endKillcam();
	self notify("end_killcam");
}

endedKillcamCleanup()
{
	self endon("end_killcam");
	self endon("disconnect");

	level waittill("game_ended");
	self endKillcam();
	self notify("end_killcam");
}